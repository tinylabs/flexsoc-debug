/**
 *  Target wrapper to access specific CSRs from com link. This is a very thin
 *  layer to wrap the autogenerated csr classes + native comm layer.
 *
 *  All rights reserved.
 *  Tiny Labs Inc
 *  2020
 */
#ifndef TARGET_H
#define TARGET_H

#include <stdint.h>
#include <stdlib.h>

#include "flexdbg_csr.h"


// ADIv5 status
typedef enum {
              ADIv5_FAULT     = 1,
              ADIv5_TIMEOUT   = 2,
              ADIv5_OK        = 4,
              ADIv5_NOCONNECT = 7
              
} adiv5_stat_t;

// Physical interfaces
typedef enum {
              PHY_SWD        = 0,
              PHY_JTAG       = 1
} phy_t;

// Bridge modes
typedef enum {
  MODE_NORMAL = 0,
  MODE_SEQUENTIAL = 1
} brg_mode_t;

// IRQ handler type
typedef void (*irq_handler_t) (uint8_t ctl, uint8_t irq);

class Target {

  static Target *inst;

private:
  flexdbg_csr *csr;
  Target (char *id);
  bool ap_enabled = false;
  int timeout = 20;
  uint8_t ap = 0;
  
 public:

  // Get singleton instance
  static Target *Ptr (void);
  static Target *Ptr (char *id);

  // Destructor
  virtual ~Target ();

  void SetTimeout (int timeout) {this->timeout = timeout;}
  
  // Validate CRC32 of interface
  bool Validate (void);

  // Must be called before AP used
  int EnableAP (bool do_enable);
  bool APEnabled (void) { return ap_enabled; }

  // Set 8bit AP (typically MEM-AP is 0)
  void SetAP (uint8_t ap) { this->ap = ap; }
  
  // General APIs
  void ReadW (uint32_t addr, uint32_t *data, uint32_t cnt);
  void ReadH (uint32_t addr, uint16_t *data, uint32_t cnt);
  void ReadB (uint32_t addr, uint8_t *data, uint32_t cnt);
  void WriteW (uint32_t addr, const uint32_t *data, uint32_t cnt);
  void WriteH (uint32_t addr, const uint16_t *data, uint32_t cnt);
  void WriteB (uint32_t addr, const uint8_t *data, uint32_t cnt);
  uint32_t ReadReg (uint32_t addr);
  void WriteReg (uint32_t addr, uint32_t val);

  // Switch modes
  void SetPhy (phy_t phy);

  // Bridge functions
  void BridgeEn (bool enabled);
  void BridgeAPSel (uint8_t ap);
  void BridgeMode (brg_mode_t mode);
  void BridgeIRQScanEn (bool enabled);
  void BridgeIRQBuf (uint32_t addr);
  
  // Read/Write ADIv5
  adiv5_stat_t WriteDP (uint8_t addr, uint32_t data);
  adiv5_stat_t ReadDP (uint8_t addr, uint32_t *data);
  adiv5_stat_t WriteAP (uint8_t addr, uint32_t data);
  adiv5_stat_t ReadAP (uint8_t addr, uint32_t *data);
  uint32_t Reset (bool pswitch);
  const char *ADIv5_Stat (adiv5_stat_t code);
  
  // Access ID/version
  uint32_t FlexsocID (void);
  
  // Async IRQ handlers
  void RegisterIRQHandler (irq_handler_t);
  void UnregisterIRQHandler (void);

  // Acknowledge IRQ
  void IRQAck (uint8_t cmd);
};

#endif /* TARGET_H */
